\chapter{Concurrency}\label{ch:concurrency}


\fEnEmp{Concurrency} ဆိုတာ တစ်ချိန်တည်းမှာ အလုပ်တစ်ခုမကကို လုပ်ဆောင်တာလို့ ယေဘူယျ ပြောနိုင်ပါတယ်။ စန္တယားတီးရင်း သီချင်းဆိုနေတာဟာ အလုပ်နှစ်ခုကို \fEn{concurrent} လုပ်နေတာပါ။ ကားမောင်းရင်း ဖုန်းလည်းပြော၊ \fEn{google map} ကနေ လမ်းကြောင်းကြည့်သွားနေတာဟာလည်း \fEn{concurrent} လုပ်နေတာပဲ။ လူတွေဟာ တစ်ချိန်တည်း အလုပ် သုံးလေးမျိုး နိုင်နိုင်နင်းနင်း လုပ်နိုင်စွမ်း ရှိကြပါတယ်။ ဒီအခန်းမှာ လေ့လာကြရမှာကတော့ ဆော့ဖ်ဝဲတွေနဲ့ သက်ဆိုင်တဲ့ \fEn{concurrency} ပါ။ \fEn{Concurrent} ပရိုဂရမ်တွေဟာ နှစ်ခု (သို့) နှစ်ခုထက်ပိုတဲ့ အလုပ် \fEn{(Task)} တွေကို တစ်ချိန်တည်း ဆောင်ရွက်တဲ့ ပရိုဂရမ်တွေ ဖြစ်ပါတယ်။ 

ဒီစာအုပ်မှာ အခုချိန်ထိ တွေ့ခဲ့တဲ့ ပရိုဂရမ် အားလုံးလိုလိုဟာ \fEn{sequential} ပရိုဂရမ်တွေပါ။ အလုပ် တစ်ခုပြီးမှ နောက်တစ်ခုလုပ်တာကို \fEn{sequential} လို့ ခေါ်တယ်။ \fEn{Sequential} က တစ်ချိန်မှာ အလုပ်တစ်ခုပဲ လုပ်တာ၊ တစ်ခုပြီးမှပဲ နောက်တစ်ခုလုပ်တာ။ ပရိုဂရမ်တစ်ခုအတွက် \fEn{problem decomposition} လုပ်တဲ့အခါ အဓိက \fEn{main task} ကို အလုပ်အခွဲ \fEn{subtask} သုံးခု ခွဲမယ်ဆိုပါစို့။ \fEn{Sequential} ပရိုဂရမ်တစ်ခုဟာ အဲဒီ \fEn{subtask} သုံးခုကို တစ်ခုပြီးမှ တစ်ခု လုပ်ဆောင်မှာပါ (ပုံ \fRefNo{\ref{fig:sequential} အပေါ် စတုဂံသုံးခု})။ ဒီ \fEn{subtask} တစ်ခုချင်းကို နောက်တစ်ဆင့် သေးငယ်တဲ့ \fEn{subtask} တွေ အဖြစ် ခွဲခြမ်းမယ်ဆိုရင်လည်း တစ်ခုပြီးမှ တစ်ခု လုပ်ဆောင်ရပါမယ်။ ပုံ (\fRefNo{\ref{fig:sequential}}) အောက်ဘက် စတုဂံလေးတွေက ဒီသဘောတရားကို ဖော်ပြထားတာ ဖြစ်တယ်။
\begin{figure}[H]
    \incfig[.8]{sequential}
    \caption{Sequential ပရိုဂရမ် အလုပ်လုပ်ပုံ။ အပေါ်က higher level task သုံးခုရဲ့ sequential သဘောကို ပြတာ။ အောက်ဘက် စတုဂံအသေးတွေက အပေါ်သုံးခုကို တစ်ခုချင်း အသေးစိတ် ထပ်ခွဲကြည့်တဲ့အခါမှာလည်း sequential ပဲဖြစ်နေတဲ့ သဘောကို ပြတာ။}
    \label{fig:sequential}
\end{figure}

\fEn{Sequential} ပရိုဂရမ်တွေလည်း သူ့နေရာနဲ့သူ အသုံးဝင်ပါတယ်။ ဒါပေမဲ့ တချို့ ပရိုဂရမ်တွေဟာ အလုပ်တွေကို တစ်ချိန်တည်း လုပ်လို့ရအောင် စီစဉ်လို့ရနိုင်မှပဲ အဆင်ပြေ အလုပ်ဖြစ်မဲ့ သဘောရှိတယ်။ ဒီလို ပရိုဂရမ်မျိုးတွေကို \fEn{concurrent} ပရိုဂရမ်လို့ ခေါ်တယ်။ \fEn{Graphical user interface (GUI)} ပရိုဂရမ်တွေ၊ ဝဘ်အပ်ပလီကေးရှင်းတွေ၊ ဒေတာဘေ့စ်တွေ စတာတွေမှာ \fEn{concurrency} ဟာ မဖြစ်မနေ လိုအပ်တယ်။ \fEn{GUI} ပရိုဂရမ် တစ်ခုဟာ ဂရပ်ဖစ် ပုံဖော်ပေးတာရော ကီးဘုဒ်နဲ့ မောက်စ်ကနေ အသုံးပြုသူ လုပ်လိုက်တဲ့ အဖြစ်အပျက်တွေကိုပါ အတုံ့အလှည့် လုပ်ဆောင်ပေးနေတာပါ။ တစ်ခါတစ်ရံ နောက်ကွယ်မှာ အလုပ်တစ်ခုကို အချိန်အတော်ကြာ လုပ်ဆောင်နေပြီး တစ်ချိန်တည်းမှာ အသုံးပြုသူကို အခြားကိစ္စတွေကို လုပ်ဆောင်လို့ ရနေစေတယ်။ ဥပမာ စာစီစာရိုက် ဆော့ဖ်ဝဲ နောက်ကွယ်မှာ စာလုံးပေါင်းသတ်ပုံနဲ့ သဒ္ဒါ စစ်ပေးနေပြီး စာလည်းဆက်ရေးလို့ ရနေတာမျိုး။ ဝဘ်နဲ့ ဒေတာဘေ့စ်လို \fEn{client-server} အပ်ပလီကေးရှင်းတွေမှာတော့ \fEn{concurrent user} အများအပြားရဲ့ \fEn{request} တွေကို ဖြည့်ဆည်းပေးဖို့ လုပ်ဆောင်ရပါတယ်။ ဒီအချက်တွေကို ကြည့်ခြင်းအားဖြင့် ဘာကြောင့် \fEn{concurrency} အရေးပါလဲ ထင်ထင်ရှားရှား မြင်နိုင်မယ် ထင်ပါတယ်။

ပုံ (\fRefNo{\ref{fig:concurrent1}}) မှာ \fEn{task 1} နဲ့ \fEn{task 2} ဟာ \fEn{concurrent} ဖြစ်တယ်။ ၎င်းတို့ရဲ့ အခွဲ \fEn{subtask} တွေကလည်း \fEn{concurrent} ဖြစ်တာ တွေ့ရပါမယ်။ ဒီသဘောကို အောက်ဘက် စတုဂံ အသေးနှစ်တန်းနဲ့  ပြထားတာ တွေ့နိုင်တယ်။ \fEn{Higher level task} တွေပဲ \fEn{concurrent} ဖြစ်နိုင်တာ မဟုတ်ပါဘူး။ \fEn{Lower level subtask} တွေကိုလည်း လိုအပ်ရင် \fEn{concurrent} လုပ်ဆောင်စေနိုင်တယ်။ ပုံ (\fRefNo{\ref{fig:concurrent2}}) မှာ \fEn{task 3} အခွဲ \fEn{subtask} သုံးခုကို \fEn{concurrent} ဖြစ်တာကို တွေ့ရပါမယ်။ \fEn{Concurrent} ပရိုဂရမ်တစ်ခုမှာ ဘယ် \fEn{task} တွေကို \fEn{concurrent} လုပ်မလဲ၊ ဘယ်ဟာတွေကိုတော့ \fEn{sequential} လုပ်ဆောင်စေမလဲ လိုအပ်သလို စီစဉ်နိုင်ပါတယ်။ 
%\fEn{CPU} နှစ်ခု ရှိရင် \fEn{task} တစ်ခုစီမှာ ပါတဲ့ ညွှန်ကြားချက်တွေကို  \fEn{CPU}  တစ်ခုစီကနေ တာဝန်ယူပြီး တပြိုင်နက် လုပ်ဆောင်နိုင်ပါမယ်။ တစ်ခုပဲ ရှိရင်လည်း \fEn{task 1} အတွက်အချိန်နည်းနည်း လုပ်လိုက်၊ \fEn{task 2} အတွက်အချိန်နည်းနည်း လုပ်လိုက်နဲ့ တစ်လှည့်စီ အလှည့်ကျ လုပ်ဆောင်နိုင်ပါတယ်။ 
\begin{figure}[H]
    \incfig[.8]{concurrent}
    \caption{Concurrent ပရိုဂရမ် ဥပမာတစ်ခု။ Task 1 နဲ့ task 2 ဟာ concurrent ဖြစ်တယ် (အပေါ်)။ အောက်က စတုဂံအသေးတွေက task 1 နဲ့ task 2 ရဲ့ subtask တွေ concurrent လုပ်ဆောင်ပုံကို ပြထားတာ။}
    \label{fig:concurrent1}
\end{figure}

\begin{figure}[H]
    \incfig[.8]{concurrency2}
    \caption{Task 3 ရဲ့ subtask တချို့ concurrent ဖြစ်နေပုံ။}
    \label{fig:concurrent2}
\end{figure}%
%

\clearpage
\section{Concurrency vs. Parallelism}
\fEn{Concurrency} အကြောင်း ဖော်ပြတဲ့အခါ \fEnEmp{parallelism} ကိုလည်း ချန်ထားခဲ့လို့မရပါဘူး။ အကြောင်းအ\allowbreak ရာနှစ်ခုက ဆက်နွယ်နေတယ်၊ စကားလုံး တစ်ခုနဲ့တစ်ခု သဘောတရား တူသလိုလို ဖလှယ်သုံးနှုန်းကြတယ် ဆိုပေမဲ့ တကယ်တမ်း တိတိကျကျ စဉ်းစားပြောရင် အဓိပ္ပါယ်  မတူကြဘူး။ အသုံးချရတဲ့ ရည်ရွယ်ချက်ရော အခြေအနေပါ မတူတာမို့လို့ \fEn{concurrent} နဲ့ \fEn{parallel} အခြေခံသဘောတရားအားဖြင့် ဘာကွာခြားလဲ ခွဲခြားမြင်ဖို့ အရေးကြီးပါတယ်။  


လုပ်စရာ \fEn{task} တွေ အများကြီးရှိမယ်၊ တစ်ခုစီကို အလှည့်ကျ အချိန်နည်းနည်းစီပေးပြီး အားလုံးရှေ့ကို တိုးတက်မှုရှိနေအောင် မျှမျှတတ ခွဲဝေလုပ်ဆောင်ပေးတာဟာ \fEn{concurrency} သဘောတရားဖြစ်တယ်။ ပုံ (၂.၂) မှာ ဒီသဘောတရားကို တွေ့နိုင်ပါတယ်။ \fEn{Parallelism} ဆိုတာကတော့ \fEn{task} တစ်ခု (သို့) \fEn{task} တွေ အများကြီးကို မြန်နိုင်သမျှ မြန်မြန်ပြီးအောင် \fEn{multi-processor} (သို့) \fEn{multi-core CPU} ကို ခွဲပေးပြီး လုပ်ဆောင်စေတာပါ။ \fEn{Concurrency} ဟာ \fEn{parallelism} အတွက် ဘယ်လိုအထောက်အကူ ပေးနိုင်လဲဆိုတာ နောက်ပိုင်းမှာ တွေ့ရပါမယ်။







