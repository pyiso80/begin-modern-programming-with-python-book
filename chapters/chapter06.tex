\chapter{အော့ဘ်ဂျက်များ}

“အော့ဘ်ဂျက် \fEn{(\textit{object})} ဆိုတာဘာလဲ” ရှုထောင့် အမျိုးမျိုးကနေ ရှင်းပြနိုင်ပါတယ်။ အပြည့်စုံဆုံး၊ အမှန်ကန်ဆုံး ဥပမာ သို့မဟုတ် အဓိပ္ပါယ်ဖွင့်ဆိုချက် ဆိုတာ မရှိပါဘူး။ သူ့နည်း သူ့ဟန်နဲ့ မှန်ကန်ကြတာပါပဲ။ ဒီအခန်းမှာတော့ အော့ဘ်ဂျက်ဆိုတာ ဘာလဲ၊ ဘယ်လိုမျိုးလဲ ခံစားလို့ရအောင်နဲ့ အခြေခံ အသုံးချတတ်ရုံလောက်ပဲ အဓိကထား လေ့လာကြမှာပါ။  လက်ရှိအခြေအနေနဲ့ သင့်တော်မဲ့ အဓိပ္ပါယ်ဖွင့်ဆိုချက် တချို့ကိုလည်း ဖော်ပြပေးသွားမှာပါ။ သိထားသင့်တဲ့ ဘာသာရပ်ဆိုင်ရာ စကားလုံး အသုံးအနှုန်းတွေကိုလည်း မိတ်ဆက်ပါမယ်။

ဆော့ဖ်ဝဲ  အော့ဘ်ဂျက်တွေဟာ အပြင်မှာ တကယ်ရှိတဲ့ အရာတွေရော တကယ်မရှိဘဲ  စိတ်ကူးသက်\allowbreak သက်ဖြစ်တဲ့ အိုင်ဒီယာတွေကိုပါ  ပရိုဂရမ်ထဲမှာ ထင်ဟပ် ဖော်ပြတယ်။ ဥပမာ ကေသီ့ဘဏ်အကောင့်၊ $\frac{7}{13}$ (အပိုင်းဂဏန်း တစ်ခု)၊ \fEn{1948-01-04} (မြန်မာပြည် လွတ်လပ်ရေးရတဲ့နေ့)၊ စန္ဒီပိုင်တဲ့ အနီရောင် တိုယိုတာကား စတာတွေကို အော့ဘ်ဂျက်တွေနဲ့ ဖော်ပြနိုင်တယ်။


အော့ဘ်ဂျက်မှာလည်း တိုက်ပ်သဘောတရား ရှိတယ်။ တိုက်ပ်တူတဲ့ အော့ဘ်ဂျက်အားလုံး ဒေတာဖွဲ့စည်းထားပုံ တူတယ်။ လုပ်ဆောင်လို့ရတဲ့ အော်ပရေးရှင်းတွေလည်း တူပါတယ်။ ဘဏ်အကောင့် အော့ဘ်ဂျက်အားလုံးဟာ လက်ကျန်ငွေနဲ့ အကောင့်နံပါတ် ပါရှိပြီး ငွေသွင်း၊ ငွေထုတ်၊ ငွေလွှဲ အော်ပရေးရှင်းတွေ လုပ်ဆောင်လို့ ရပါမယ်။ 

အော့ဘ်ဂျက်တွေရဲ့ တိုက်ပ်နဲ့ နီးနီးစပ်စပ် ဆက်နွယ်နေတာကတော့ ကလပ်စ် \fEn{(\textit{class})} သဘောတရားပါ။ ကလပ်စ်ကို တိုက်ပ်တူအော့ဘ်ဂျက်တွေ ဖန်တီးဖို့အတွက် သတ်မှတ်ထားတဲ့ ပရိုဂရမ်ကုဒ် အစုအဝေးလို့ ယေဘုယျ ပြောနိုင်ပါတယ်။ \fCode{Account} ကလပ်စ်၊ \fCode{date} ကလပ်စ်၊ \fCode{Fraction} ကလပ်စ် စသည်ဖြင့် အော့ဘ်ဂျက် တိုက်ပ် တစ်မျိုးအတွက် ကလပ်စ်တစ်ခု ရှိမှာပါ။ တိုက်ပ်တူ အော့ဘ်ဂျက်တွေ အားလုံးမှာ ပါဝင်မဲ့ အချက်အလက်တွေ၊ အော်ပရေးရှင်းတွေနဲ့ အော့ဘ်ဂျက် ဖန်တီးယူတဲ့ ဖန်ရှင်တွေကို ကလပ်စ်တစ်ခုနဲ့ သတ်မှတ်ရတာပါ။ ကလပ်စ်ကနေ  အော့ဘ်ဂျက်တွေ (တိုက်ပ် တူပါမယ်) ထုတ်ယူရတာ ဖြစ်တဲ့အတွက် ကလပ်စ်ကို အော့ဘ်ဂျက် စက်ရုံလို့လည်း ဆိုနိုင်ပါတယ်။ ပုံစံတူ အော့ဘ်ဂျက်တွေ ထုတ်ပေးတာမို့လို့ ကလပ်စ်ဆိုတာ အော့ဘ်ဂျက်တည်ဆောက်တဲ့ \fEn{blueprint} သို့မဟုတ် \fEn{template} ပဲလို့ ယူဆတာဟာလည်း သဘာဝကျတယ် ဆိုရမှာပါ။ 

အော့ဘ်ဂျက်တွေကို အက်ဘ်စရက်ရှင်း \fEn{(\textit{abstraction})} အနေနဲ့လည်း ရှုမြင်နိုင်တယ်။ ဘယ်လို ဖန်တီး တည်ဆောက်ထားလဲ မသိဘဲ အသုံးပြုလို့ရတဲ့ အရာအားလုံးကို အက်ဘ်စရက်ရှင်းလို့ ဆိုနိုင်တယ်။ အပြင်မှာသုံးကြတဲ့ ကား၊ တီဗွီ၊ ကွန်ပျူတာ စတာတွေဟာ အက်ဘ်စရက်ရှင်းတွေ ဖြစ်တယ်။ ဖန်ရှင်တွေဟာလည်း အက်ဘ်စရက်ရှင်းတွေပါပဲ။ အော့ဘ်ဂျက်တွေကတော့ ဒေတာနဲ့ အော်ပရေးရှင်း တွဲဖက်ပေါင်းစပ်ထားတဲ့ အက်ဘ်စရက်ရှင်းတွေပါ။ အော့ဘ်ဂျက်တစ်ခုနဲ့ တွဲဆက်ထားတဲ့ အော်ပရေးရှင်းတွေဟာ အဲ့ဒီအော့ဘ်ဂျက်ရဲ့ ဒေတာတွေကို အသုံးပြုတယ်။ အဲ့ဒီအော့ဘ်ဂျက်ရဲ့ ဒေတာအပေါ် သက်ရောက်မှု ရှိနိုင်တယ်။ အခြားအော့ဘ်ဂျက်ရဲ့ ဒေတာကို မသုံးဘူး။ သက်ရောက်မှူလည်း မရှိစေဘူး။ အော့ဘ်ဂျက် အတွင်းပိုင်း ဒေတာတွေ ဖွဲ့စည်းထားပုံနဲ့ တိုက်ပ်ကို  မသိဘဲ အော့ဘ်ဂျက်ကို အသုံးပြုလို့ရတယ်။ အော်ပရေးရှင်းတွေဟာ တကယ်ကတော့ အော့ဘ်ဂျက်ဒေတာ အသုံးပြုတဲ့ ဖန်ရှင်တွေပါပဲ။ ဒီဖန်ရှင်တွေ ဘယ်လိုရေးထားလဲ၊ ဒေတာကို ဘယ်ပုံဘယ်နည်း အသုံးပြုတာလဲ သိစရာမလိုဘဲ အသုံးပြုလို့ ရပါတယ်။ 

ဖန်ရှင် အသင့်ရှိပြီးသား ဆိုရင်  အသုံးပြုလို့ ရသလို ကလပ်စ် အသင့်ရှိပြီးသား ဆိုရင် အော့ဘ်ဂျက်တွေ ဖန်တီးအသုံးပြုနိုင်ပါတယ်။ ဖန်ရှင်ရေးရတာ ခက်ခဲနိုင်ပါတယ်။ ရှိပြီးသား ဖန်ရှင်သုံးတာကတော့ မခက်ပါဘူး။ ဒီသဘောပါပဲ။ ကလပ်စ်သတ်မှတ်ရတာ၊ ဒီဇိုင်းလုပ်ရတာ ရှုပ်ထွေး ခက်ခဲနိုင်ပါတယ်။ ရှိပြီးသား ကလပ်စ်ကနေ အော့ဘ်ဂျက် ဖန်တီးအသုံးပြုရတာ မခက်ပါဘူး။ အသုံးပြုသူ လွယ်ကူအဆင်ပြေစေဖို့ တည်ဆောက်သူက အဓိကစဉ်းစား ဖြေရှင်းရတာပါ။ သုံးစွဲသူအဆင့်ကနေ စတင်ပြီး တည်ဆောက်သူ ပရိုဂရမ်မာ ဖြစ်လာအောင် တစ်ဆင့်ချင်း တက်လှမ်းဖို့ဟာ အဓိကပန်းတိုင်ပါ။ အော့ဘ်ဂျက်မိတ်ဆက် ခဏရပ်၊ အခုပဲ လက်တွေ့စမ်းသပ် ကြည့်လိုက်ရအောင် $\ldots$

\section{\fSecCode{date}, \fSecCode{time} and \fSecCode{datetime}}
ဆော့ဖ်ဝဲ အပ်ပလီကေးရှင်းတွေမှာ အချိန်နာရီ၊ နေ့ရက်တွေနဲ့ တွက်ချက်ဆုံးဖြတ်ရတာတွေ အမြဲလိုလို ပါတယ်။ ဒါကြောင့်  အချိန်နဲ့သက်ဆိုင်တဲ့ အချက်အလက်တွေကို စနစ်တကျ ကိုင်တွယ်ဖြေရှင်းတတ်ဖို့ လေ့လာထားရပါမယ်။  အချိန်နဲ့ နေ့ရက်အတွက် \fCode{date}\fEn{,} \fCode{time}\fEn{,} \fCode{datetime} ကလပ်စ်တွေ ထောက်ပံပေးထားတဲ့ \fCode{datetime} လိုက်ဘရီ အသုံးပြုပါမယ်။ \fCode{date} ကလပ်စ်ကနေ ဖန်တီးယူတဲ့ အော့ဘ်ဂျက်တစ်ခုဟာ အနောက်တိုင်းပြက္ခဒိန် နေ့ရက်တစ်ရက်ကို ဖော်ပြတယ်။ ခုနှစ်၊ လ၊ ရက် အချက်အလက် သုံးခုပါဝင်တယ်။ မြန်မာပြည် လွတ်လပ်ရေးရခဲ့တဲ့ နေ့ရက်ကို ဖော်ပြရင် အခုလိုပါ
\begin{codetxt}
>>> from datetime import *
>>> date(1948, 1, 4)
datetime.date(1948, 1, 4)
\end{codetxt}
ဒုတိယလိုင်းက အော့ဘ်ဂျက် ဖန်တီးတာပါ။ ဖန်ရှင်ခေါ်တာနဲ့ ပုံစံတူတာ တွေ့ရတယ်။ အော့ဘ်ဂျက်ဖန်တီးဖို့ စပယ်ရှယ် ဖန်ရှင်တစ်ခု ခေါ်ထားတယ်လို့ ယူဆနိုင်ပါတယ် (နောက်ပိုင်း ကလပ်စ်အခန်းမှာ အသေးစိတ် လေ့လာရမှာပါ)။ ကလပ်စ်ကနေ အော့ဘ်ဂျက် ဖန်တီးယူတာကို \fEnEmp{instantiation} လို့ခေါ်ပြီး ရရှိလာတဲ့ အော့ဘ်ဂျက်ကို အဲဒီကလပ်စ်ရဲ့ \fEnEmp{instance} လို့လည်း ခေါ်ပါတယ်။ 
\begin{codetxt}
>>> mmid = date(1948, 1, 4)
\end{codetxt}
အော့ဘ်ဂျက်ကို ဗေရီရေဘဲလ်နဲ့ အဆိုင်းမန့်လုပ်တာပါ။ အော့ဘ်ဂျက်ကို \fCode{mmid} ဗေရီရေဘဲလ်နဲ့  ရည်ညွှန်းအသုံးပြုလို့ ရမှာဖြစ်တယ်။ 
\begin{codetxt}
>>> mmid.year
1948
\end{codetxt}
\fEn{Dot notation} ( \fCodeBf{.} အမှတ်အသား)  နဲ့ အော့ဘ်ဂျက်ရဲ့ ခုနှစ်ကို ရယူထားတာပါ။ လနဲ့ ရက်ကိုလည်း အလားတူနည်းလမ်းနဲ့ ယူကြည့်နိုင်တယ်။
\begin{codetxt}
>>> mmid.month
1
>>> mmid.day
4
\end{codetxt}
အော့ဘ်ဂျက်တစ်ခုမှာ ပါဝင်တဲ့ ဒေတာကို \fEnEmp{attribute} လို့ ခေါ်တယ်။  \fEn{Attribute} တွေဟာ အော့ဘ်ဂျက်ရဲ့ လက်ရှိအခြေအနေ \fEn{(\textit{state})} ကိုဖော်ပြတယ်။ စတိတ် ပြောင်းလဲနိုင်တဲ့ အော့ဘ်ဂျက်တွေကို \fEnEmp{mutable object} လို့ ခေါ်တယ်။ စတိတ် မပြောင်းလဲနိုင်တဲ့ အော့ဘ်ဂျက်တွေကို  \fEnEmp{immutable object} လို့ ခေါ်တယ်။ \fCode{date} အော့ဘ်ဂျက်တွေဟာ \fEn{immutable object} တွေပါ။ ဆိုလိုတာက \fEn{attribute} တွေဖြစ်တဲ့ \fCode{year}\fEn{,} \fCode{month}\fEn{,} \fCode{day} တန်ဖိုးတွေ မပြောင်းလဲနိုင်ပါဘူး။ 




ခုနှစ်၊ လ၊ ရက် အတွက် \fEn{attribute} သုံးခုဟာ \fCode{date} အော့ဘ်ဂျက် တစ်ခုစီတိုင်းအတွက် ကိုယ်ပိုင်ပါရှိမှာပါ။ ဆိုလိုတာက ‌အောက်ပါ \fCode{usid} အော့ဘ်ဂျက်ရဲ့ \fEn{attribute} တွေနဲ့ ခုနက \fCode{mmid} ရဲ့ \fEn{attribute} တွေဟာ သီးခြားစီပဲ။ နံမည်တူပေမဲ့ တစ်ခုနဲ့တစ်ခု မရောယှက်ဘူး။
\begin{codetxt}
>>> usid = date(1776, 7, 4)
\end{codetxt}
\betweenminted{\medskipamount}
\begin{codetxt}
>>> usid.year
1776
>>> usid.month
7
>>> usid.day
4
\end{codetxt}
အခုလို တန်ဖိုးပြန်ယူကြည့်ရင်လည်း ဖြစ်သင့်တဲ့အတိုင်း သက်ဆိုင်ရာ အော့ဘ်ဂျက်ရဲ့ \fEn{attribute} တန်ဖိုးတွေပဲ ပြန်ရတာပေါ့။ လွတ်လပ်ရေး ရခဲ့တဲ့နေ့က ဘာနေ့ဖြစ်မလဲ 
\begin{codetxt}
>>> usid.isoweekday()
4
>>> mmid.isoweekday()
7
\end{codetxt}
ဖန်ရှင်တစ်ခုတည်းကို မတူညီတဲ့ အော့ဘ်ဂျက်နှစ်ခုအပေါ်မှာ အသုံးချတာ ဖြစ်တယ်။ ဒေါ့ထ်ကိုပဲ သုံးတယ်။ ပထမတစ်ခုက \fCode{usid} အော့ဘ်ဂျက်၊ နောက်တစ်ခုက \fCode{mmid} အော့ဘ်ဂျက်အပေါ်မှာ သုံးထားတာပါ။ အမေရိကန်  လွတ်လပ်ရေးရခဲ့တာ ကြာသာပတေးနေ့၊ မြန်မာကတော့ တနင်္ဂနွေနေ့ပါ (တနင်္လာက တစ်၊ တနင်္ဂနွေက ခုနှစ်ပါ)။ \fCode{isoweekday} ဖန်ရှင်ကို အော့ဘ်ဂျက်တစ်ခုအပေါ် အသုံးပြုတဲ့အခါ ၎င်းအော့ဘ်ဂျက်နဲ့ သက်ဆိုင်တဲ့ ဒေတာနဲ့ ဖန်ရှင်က အလုပ်လုပ်သွားတာပါ။ ဒါကြောင့်လည်း \fEn{attribute} မတူတဲ့ အော့ဘ်ဂျက်တွေအပေါ်မှာ အသုံးချတဲ့အခါ မတူညီတဲ့ ရလဒ်တွေ ထွက်လာရတာပေါ့။ ‘ဒေတာနဲ့ အော်ပရေးရှင်း တွဲဖက်ထားတယ်’ ဆိုတာ ဒီသဘောတရားကို ဆိုလိုတာပါ။ အော့ဘ်ဂျက်ဒေတာနဲ့ တွဲဖက်အလုပ်လုပ်တဲ့ ဖန်ရှင်တွေကို မက်သဒ် \fEn{(\textit{method})} လို့ ခေါ်တယ်။ နောက် မက်သဒ်တစ်ခုက \fCode{isoformat} ပါ။ နေ့ရက်ကို စားသားအဖြစ် \fCode{'yyyy-mm-dd'} ဖော့မတ်နဲ့ ပြန်ပေးတယ်။
\begin{codetxt}
>>> usid.isoformat()
'1776-07-04'
>>> mmid.isoformat()
'1948-01-04'
\end{codetxt}

\fCode{date} တစ်ခု ဖန်တီးတဲ့အခါ ခုနှစ်၊ လ၊ ရက် နေရာ မှန်ဖို့ အရေးကြီးပါတယ်။ \fCode{date(1948,4,1)} လို့ ရေးမိရင် လေးလပိုင်း တစ်ရက်နေ့ ဖြစ်သွားမှာပါ။ ဒါပေမဲ့ \fEn{Python} မှာ အာ့ဂုမန့်တွေကို နံမည်နဲ့ တွဲပြီး ထည့်ပေးလို့ရတယ်။ 
\begin{codetxt}
>>> mmid = date(day=4, year=1948, month=1)
\end{codetxt}
ဒီနည်းနဲ့ ဆိုရင်တော့ \fCode{year}\fEn{,} \fCode{month}\fEn{,} \fCode{day} ကြိုက်သလို အစီအစဉ်နဲ့ ထည့်လို့ရမှာပါ။ 

\fCode{replace} မက်သဒ် ဘယ်လို အလုပ်လုပ်လဲ ကြည့်ရအောင်
\begin{codetxt}
>>> usid = date(1776, 7, 4)
>>> usid100 = usid.replace(year=1876)    
\end{codetxt}
နဂို \fCode{usid} နေ့ရက်ရဲ့ ခုနှစ်ကို \fCode{1876} နဲ့ အစားထိုးထားတဲ့ အော့ဘ်ဂျက် အသစ်တစ်ခု ပြန်ရပါတယ်။ နဂိုရက်စွဲက မပြောင်းသွားဘူး (\fCode{date} အော့ဘ်ဂျက် ဟာ \fEn{immutable} ဖြစ်တာ သတိပြုပါ)။ 
\begin{codetxt}
>>> usid
datetime.date(1776, 7, 4)
>>> usid100
datetime.date(1876, 7, 4)    
\end{codetxt}
ခုနှစ်၊ လ၊ ရက် သုံးခုလုံး အစားထိုးချင်ရင်
\begin{codetxt}
>>> dt1 = date(2000,2,21)
>>> dt2 = dt1.replace(2010,10,10)
>>> dt3 = dt1.replace(day=20,month=12,year=2020)
\end{codetxt}
အာ့ဂုမန့် နံမည် မပါရင် ခုနှစ်၊ လ၊ ရက် အစဉ်အတိုင်း ဖြစ်ရပါမယ်။ ရလဒ်တွေ ကြည့်ရင်
\begin{codetxt}
>>> dt1
datetime.date(2000, 2, 21)
>>> dt2
datetime.date(2010, 10, 10)
>>> dt3
datetime.date(2020, 12, 20)
\end{codetxt}
ခုနှစ်၊ လ၊ ရက် တခုခု ချန်ထားကြည့်ပါ
\begin{codetxt}
>>> dt4 = dt1.replace(2020)
>>> dt5 = dt1.replace(2030,11) 
\end{codetxt}
ချန်ထားခဲ့တာတွေ နဂိုအတိုင်းရှိပါမယ်
\begin{codetxt}
>>> dt4
datetime.date(2020, 2, 21)
>>> dt5
datetime.date(2030, 11, 21)
\end{codetxt}
ရက်တစ်ခုတည်း အစားထိုးမယ်ဆိုရင် နံမည်နဲ့တွဲတဲ့ နည်းကပဲ အဆင်ပြေပါမယ်
\begin{codetxt}
>>> dt6 = dt1.replace(day=28)
>>> dt6
datetime.date(2000, 2, 28)
\end{codetxt}
နံမည်မပါရင် ခုနှစ်၊ လ၊ ရက် အစဉ်အတိုင်းဖြစ်တာကြောင့် ခုနှစ်ကို အစားထိုးမှာပါ
\begin{codetxt}
>>> dt7 = dt1.replace(28)
>>> dt7
datetime.date(28, 2, 21)
\end{codetxt}



\subsection*{\fSubSecCodeBf{time} and \fSubSecCodeBf{datetime}}
နေ့ရက်နဲ့ အချိန် တွဲရက်ကို \fCode{datetime}\fEn{,} ရက်စွဲမလိုဘဲ အချိန်ပဲဆိုရင် \fCode{time} သုံးပါတယ်
\begin{codetxt}
>>> t1 = time(10, 15, 20)
>>> t1.hour
10
>>> t1.minute
15
>>> t1.second
20
>>> mmid2 = datetime(1948,1,4,4,20)
>>> mmid3 = datetime(1948,1,4,4,20,0)
>>> mmid2.second
0
>>> mmid3.second
0
\end{codetxt}

\subsection*{\fSubSecCodeBf{timedelta}}
အချိန်ကာလနဲ့ ပါတ်သက်ပြီး မဖြစ်မနေ သိထားသင့်တဲ့ နောက်ထပ်ကလပ်စ် တစ်ခုကတော့ ကြာချိန် \fEn{(duration)} ကို ဖော်ပြတဲ့ \fCode{timedelta} ကလပ်စ်ပါ။
\begin{codetxt}
>>> duration = timedelta(
... days=50,
... seconds=27,
... microseconds=10,
... milliseconds=29000,
... minutes=5,
... hours=8,
... weeks=2
... )
>>> duration
datetime.timedelta(days=64, seconds=29156, microseconds=10)
\end{codetxt}
(\fCode{...} က အော်တို ထည့်ပေးသွားတာ။ ကိုယ်တိုင် ရိုက်ထည့်စရာမလိုဘူး။ တစ်လိုင်းချင်း \fEn{Enter} ခေါက်သွားရုံပဲ။ အပိတ်ဝိုက်ကွင်းမှာ စတိတ်မန့် ဆုံးတယ်ဆိုတာ အင်တာပရက်တာက နားလည်တယ်။)

အော့ဘ်ဂျက် အသုံးပြုသူအနေနဲ့ အချိန်ကာလ ကြာမြင့်ချိန်ကို \fCode{days}\fEn{,} \fCode{weeks}\fEn{,} \fCode{hours} $\ldots$ စတာတွေနဲ့ သတ်မှတ်လို့ရတယ်။ ၎င်းတို့ကို ရက်၊ စက္ကန့်၊ မိုက်ခရိုစက္ကန့် ဖွဲ့ပြီး အော့ဘ်ဂျက် အတွင်းပိုင်း \fCode{days}\fEn{,} \fCode{seconds}\fEn{,} \fCode{microseconds} \fEn{attributes}  ဒေတာအနေနဲ့ သိမ်းမှာပါ။ 
\begin{codetxt}
>>> twoweeks_twomins = timedelta(weeks=1,days=7,minutes=2)
>>> twoweeks_twomins
datetime.timedelta(days=14, seconds=120)
\end{codetxt}

ဖော်ပြခဲ့ပြီးတဲ့ အော့ဘ်ဂျက်တွေနဲ့ အပေါင်း၊ အနှုတ် အော်ပရေးရှင်းတွေ လုပ်လို့ရပါတယ်။ ဥပမာတချို့ လေ့လာကြည့်ပါ
\begin{codetxt}
>>> dt1 = datetime(2021,2,10,23,45,43)
>>> dt2 = datetime(2022,2,10,23,44,42)
>>> duration1 = dt2 - dt1
>>> duration1
datetime.timedelta(days=364, seconds=86339)
\end{codetxt}
ဒီလိုစစ်ကြည့်ပါ
\begin{codetxt}
>>> dt3 = dt1 + duration1
>>> dt3
datetime.datetime(2022, 2, 10, 23, 44, 42)
>>> dt4 = dt2 - duration1
>>> dt4
datetime.datetime(2021, 2, 10, 23, 45, 43)
>>> dt1 == dt4
True
>>> dt2 == dt3
True
\end{codetxt}


\section{\fSecCodeBf{list}}
\fEnEmp{List} ဆိုတာ အိုက်တမ် \fEn{item} တွေ အတွဲလိုက် စုစည်းထားဖို့ အသုံးပြုတဲ့ စထရက်ချာတစ်မျိုး ဖြစ်တယ်။ \fEn{Python} မှာ \fCode{list} အော့ဘ်ဂျက်တွေကို  \fEn{item} တွေ အတွဲလိုက် စုစည်းထားဖို့ သုံးတယ်။ ဘာအိုက်တမ်မှ မပါတဲ့ \fCode{list} အသစ်တစ်ခု လိုချင်ရင် ဒီလို
\begin{codetxt}
>>> odds = list()
\end{codetxt}
ဒီ \fCode{lsit} ထဲမှာ ပါတွေပါလဲ 
\begin{codetxt}
>>> odds
[]
\end{codetxt}
လေးထောင့်ကွင်းနဲ့ \fCode{list} ကိုပြပေးတယ်။ လက်ရှိ \fCode{list} ထဲမှာ အိုက်တမ် မရှိသေးဘူး။ အိုက်တမ် တစ်ခုချင်း ထည့်ချင်ရင် \fCode{append} မက်သဒ်ရှိတယ်
\begin{codetxt}
>>> odds.append(1)
>>> odds.append(3)
>>> odds.append(5)
>>> odds.append(7)
\end{codetxt}
\betweenminted{\medskipamount}
\begin{codetxt}
>>> odds
[1, 3, 5, 7]
\end{codetxt}
ပါဝင်တဲ့ အိုက်တမ်တစ်ခုစီကို ကော်မာခြားပြီး ပြတယ်။ နောက်ထပ် နည်းလမ်းတစ်ခုနဲ့လည်း \fCode{list} ဖန်တီးလို့ ရတယ်။ လေးထောင့်ကွင်း သုံးတဲ့နည်းပါ
\begin{codetxt}
>>> empty = []
>>> lst1 = [1,2,3,4,5,6]
>>> empty
[]
>>> lst1
[1, 2, 3, 4, 5, 6]
\end{codetxt}

\fCode{list} ဟာ \fEn{mutable} ဖြစ်တယ်။ အိုက်တမ် နောက်တစ်ခု ထပ်ထည့်ကြည့်ပါ
\begin{codetxt}
>>> odds.append(9)
>>> odds
[1, 3, 5, 7, 9]
\end{codetxt}
နဂို အော့ဘ်ဂျက်မှာ အိုက်တမ်တစ်ခု ထပ်တိုးသွားတာ။ အော့ဘ်ဂျက်ရဲ့ စတိတ် ပြောင်းသွားတယ်။ အိုက်တမ်တစ်ခုကို ဖယ်ထုတ်ချင်ရင် 
\begin{codetxt}
>>> odds.pop(0)
1
>>> odds
[3, 5, 7, 9]    
\end{codetxt}
\fCode{list} အိုက်တမ်တွေရဲ့ တည်နေရာကို \fEn{index} လို့ခေါ်တယ်။ သုညနဲ့ စတယ်။ ဒုတိယက တစ်၊ တတိယက နှစ် စသည်ဖြင့် ဖြစ်မယ်။ အခု \fCode{odds} မှာ အိုက်တမ် လေးခုရှိနေတယ်။ \fCode{7} ဖြုတ်ချင်ရင် \fEn{index} နံပါတ် \fCode{2} ကို \fCode{pop} လုပ်ရမှာ
\begin{codetxt}
>>> odds.pop(2)
7
>>> odds
[3, 5, 9]
\end{codetxt}
ဖယ်လိုက်တဲ့ အိုက်တမ်တွေ နဂိုနေရာမှာ ပြန်ထည့်ချင်တယ်ဆိုပါစို့။ \fCode{insert} ရှိပါတယ်
\begin{codetxt}
>>> odds.insert(2, 7)
>>> odds
[3, 5, 7, 9]
>>> odds.insert(0,1)
>>> odds
[1, 3, 5, 7, 9]
\end{codetxt}

အိုက်တမ် အစားထိုးတာ၊ \fEn{index} နဲ့ နေရာတစ်ခုက အိုက်တမ်ကို ပြန်ထုတ်ကြည့်တာကို လေးထောင့်ကွင်းနဲ့ ရေးနည်းလည်းရှိတယ်
\begin{codetxt}
>>> evens = [2,4,6,8,10,12]
>>> evens[0]
2
>>> evens[1]
4
\end{codetxt}
\fCode{pop} နဲ့ မတူတာကို သတိပြုပါ။ \fCode{pop} က အိုက်တမ်ကို ဖယ်ထုတ်လိုက်တယ်။ စတိတ်ပြောင်းလဲစေတယ်။ အခုနည်းက မဖယ်ထုတ်ဘူး။ အိုက်တမ်ကိုပဲ ပြန်ပေးတာပါ။
\begin{codetxt}
>>> evens
[2, 4, 6, 8, 10, 12]
\end{codetxt}
\fCode{replace} နဲ့ သဘောတရားတူတာကတော့ 
\begin{codetxt}
>>> evens[5] = 14
>>> evens
[2, 4, 6, 8, 10, 14]
\end{codetxt}
နောက်ဆုံး နေရာ (\fEn{index} နံပါတ် \fCode{5}) ကို \fCode{14} လဲထည့်လိုက်တာ။

ဗေရီရေဘဲလ် နှစ်ခုက အော့ဘ်ဂျက်တစ်ခုတည်းကို ရည်ညွှန်းနေရင် သတိပြုသင့်တဲ့ ထူးခြားချက်တွေ ရှိလာပါတယ်။ 
\begin{codetxt}
>>> fruits = ['mango', 'apple', 'strawberry', 'kiwi']
>>> myfav = fruits
\end{codetxt}
ဒီလိုဆိုရင် အော့ဘ်ဂျက် တစ်ခုတည်းကို \fCode{fruits} ရော \fCode{myfav} နဲ့ပါ သုံးလို့ရပါမယ်။ \fCode{fruits} နဲ့ အိုက်တမ်တစ်ခု ထပ်ထည့်ကြည့်မယ်
\begin{codetxt}
>>> fruits.append('orange')
\end{codetxt}
\fCode{myfav} ပါ လိုက်ပြောင်းတာကို တွေ့ရမှာပါ
\begin{codetxt}
>>> myfav
['mango', 'apple', 'strawberry', 'kiwi', 'orange']
\end{codetxt}
\fEn{Mutable} အော့ဘ်ဂျက်တွေမှာ ဒီအချက်ကို သတိပြုဖို့ လိုပါတယ်။ ဗေရီရေဘဲလ် တစ်ခုကနေ အော့ဘ်ဂျက် စတိတ်ကို ပြောင်းလဲတဲ့အခါ အဲ့ဒီအော့ဘ်ဂျက်ကို ရည်းညွှန်းတဲ့ အခြား ဗေရီရေဘဲလ် အားလုံးကလည်း အပြောင်းအလဲကို မြင်ရမှာ ဖြစ်တယ်။ \fEn{Immutable} ဆိုရင်တော့  စတိတ်မပြောင်းနိုင်တာကြောင့် ဒီလိုကိစ္စမျိုး စဉ်းစားစရာ မလိုဘူး။












\afterpage{\blankpage}