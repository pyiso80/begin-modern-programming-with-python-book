\chapter{ဒေတာဘေ့စ်များနှင့် ဆက်သွယ်ဆောင်ရွက်ခြင်း}

ဒေတာဘေ့စ်တွေဟာ ကနေ့ခေတ် \fEn{information system} အားလုံးရဲ့ အဓိကကျောရိုးလို့ ဆိုနိုင်ပါတယ်။ ၎င်းတို့ဟာ \fEn{web application} တွေမှာ အသုံးပြုသူ ကိုယ်ရေးအချက်အလက်ကနေ ဘဏ္ဍာရေးဆိုင်ရာ အဖွဲ့အစည်းကြီးတွေ ငွေဝင်ငွေထွက် စာရင်းအထိ အရာအားလုံး သိမ်းဆည်းပေးတဲ့ စနစ်တွေ ဖြစ်တယ်။ ကျန်းမာရေး၊ စီးပွားရေး၊ ပညာရေး၊ ဘဏ္ဍာရေး စတဲ့ ကဏ္ဍ အားလုံးမှာ အချက်အလက်တွေ ထိထိရောက်ရောက် သိမ်းဆည်း စီမံနိုင်ဖို့အတွက် ဒေတာဘေ့စ်တွေက မရှိမဖြစ်ပါပဲ။ အရေးပါတဲ့ ဒီလို ကဏ္ဍတွေမှာ လုပ်\allowbreak ငန်းအသီးသီး မှန်ကန်တိကျ၊ နောက်ဆုံးရ အချက်အလက်တွေနဲ့  \fEn{informed decision} ချနိုင်ဖို့ အဓိကဆောင်ရွက်ပေးတဲ့ စနစ်တွေလည်း ဖြစ်တယ်။

ဒီအခန်းမှာ \fEn{Python} နဲ့ ဒေတာဘေ့စ် ချိတ်ဆက်အသုံးပြုပုံကို လေ့လာကြမှာပါ။ အခြေ\allowbreak ခံ ဒေတာဘေ့စ် \fEn{concept} တွေကိုတော့ ဒီစာအုပ်မှာ အကျဉ်းချုံးလောက်ပဲ ဖော်ပြပေးနိုင်မယ်။ ပရော်ဖက်ရှင်နယ် အဆင့် ဒေတာဘေ့စ် ပရိုဂရမ်းမင်း အတွက်ဆိုရင် တချို့အပိုင်းတွေကို ထဲထဲဝင်ဝင် ဆက်လက် လေ့လာရပါလိမ့်မယ်။ ကိုးကားစာအုပ်တွေ နောက်ဆုံးမှာ ကြည့်နိုင်ပါတယ်။

% \fEn{Databases are the backbone of modern information systems. They store everything from user data in web applications to transaction records in financial systems. They are used in virtually every industry, including finance, healthcare, e-commerce, and education, to store and manage data efficiently, enabling businesses to make informed decisions based on accurate and up-to-date information.}

\section{Database Management Systems}
‘ဒေတာဘေ့စ်’ ဆိုတာ အချက်အလက် အမြောက်အများ ရေရှည်သိမ်းဆည်းပေးတဲ့ စနစ်လို့ အကြမ်းဖျဉ်း ပြောနိုင်ပါတယ်။ သာမန်အားဖြင့် ရေရှည်သိမ်းထားချင်ရင် ဖိုင်စနစ် သုံးလို့ရပေမဲ့ ဒေတာ များလာတဲ့အခါ အဆင်မပြေနိုင်တော့ဘူး။ ပြန်လည်ရှာဖွေရတာ၊ ထုတ်ယူရတာ၊ အမြဲတမ်း မှန်ကန်ကိုက်ညီနေအောင် ထိန်းသိမ်းရတဲ့ ကိစ္စတွေအတွက် ပြဿနာရှိလာတယ်။ \fEn{Database Management Systems (DBMS)} တွေကို ဒီအခက်အခဲတွေ ဖြေရှင်းပေးဖို့  တီထွင်ခဲ့ကြတာပါ။ အချက်အလက် မှန်ကန်တိကျခြင်း၊ လုံခြုံမှုရှိခြင်းနှင့် အလွယ်တကူ \fEn{access} လုပ်နိုင်ခြင်းအတွက် \fEn{DBMS} တွေမှာ ဦးစားပေး ထည့်သွင်း စဉ်းစားထားတယ်။ ဒေတာပမာဏ အများအပြား စနစ်တကျ ထိထိရောက်ရောက် စုဆောင်း၊ သိမ်းဆည်း၊ စီမံဖို့အတွက် အားကိုးအားထားပြုရတဲ့ စနစ်တွေလို့ ဆိုရမယ်။  

\subsection*{သမိုင်းအကျဉ်း}
ဒေတာဘေ့စ်တွေရဲ့ မူလအစ \fEn{concept} ဟာ \fEn{IBM} ကုမ္ပဏီက \fEn{IMS (Information Management System)} လို စနစ်တွေ တည်ဆောက်ခဲ့တဲ့ ၁၉၆၀ ခုနှစ်တွေလောက်ကို ပြန်သွားနိုင်တယ်။ အဲ့ဒီစနစ်တွေက \fEn{hierarchical} ဖြစ်တယ်။ ဆိုလိုတာက ဒေတာသိမ်းတဲ့ စထရက်ချာက သစ်ပစ်လိုပဲ၊ အပင်ရဲ့ အမြစ်၊ အရွက်၊ အကိုင်းအခက်တွေ ဆက်စပ်နေသလိုပုံစံနဲ့ အချက်အလက်တွေကို သိမ်းတယ်။ \fEn{Parent-child relationship} နဲ့ သိမ်းတာလို့လည်း ဆိုနိုင်တယ်။ ၁၉၇၀ ခုနှစ်တွေမှာတော့ \fEn{Edgar F. Codd} က ယနေ့ခေတ် \fEn{Relational Database Management System (RDBMS)} ရဲ့ အခြေခံအုတ်မြစ် ဖြစ်လာတဲ့ \fEn{Relational Data Model} ကို စတင်မိတ်ဆက်ခဲ့တယ်။ \fEn{Relational model} မှာက ဒေတာသိုလှောင်သိမ်းဆည်းဖို့ \fEn{table} တွေကို အသုံးပြုပြီး \fEn{SQL (Structured Query Language)} လို့ခေါ်တဲ့ \fEn{programming language} ကို ထောက်ပံပေးပါတယ်။ 

\subsection*{SQL Language}
\fEn{SQL} ဟာ  \fEn{table} ဒေတာ အမြောက်အများကနေ မိမိစူးစမ်းလိုတဲ့ အချက်အလက်ကို အလွယ်တကူ ထုတ်ယူ (သို့) မေးမြန်းလို့ရအောင် ကူညီထောက်ပံပေးဖို့ အဓိကရည်ရွယ်တယ်။ “ကေသီ ဒီနှစ် ဇွန်လစာမေးပွဲမှာ ဘာသာရပ်အသီးသီး ရမှတ်ဘယ်လောက်လဲ” လို  ခပ်ရိုးရိုး မေးခွန်းကနေ “ဘယ်ကျောင်းသူ ကျောင်းသား တွေ စာမေးပွဲအားလုံးမှာ သင်္ချာရမှတ် ၉၅ မှတ်အထက် သုံးနှစ်ဆက်တိုက် ရကြလဲ” ဆိုတဲ့ အတော်လေး ရှုပ်ထွေးတဲ့  \fEn{query} မျိုးတွေထိ မြန်ဆန်ထိရောက်စွာ လုပ်ဆောင်ပေးနိုင်ပါတယ်။ 

အချက်အလက် ထုတ်ယူတာအပြင် ဒေတာဘေ့စ် အသစ်ဆောက်တာ၊ \fEn{table} ဆောက်တာ၊ ပြန်ဖျက်တာ စတဲ့ကိစ္စတွေကိုလည်း \fEn{SQL} နဲ့ပဲ လုပ်ရပါတယ်။ \fEn{Table} မှာ \fEn{record} အသစ်ထည့်တာ၊ ရှိပြီးသား \fEn{record} ကို \fEn{update} လုပ်တာ၊ ဖျက်ပစ်တာ စတာတွေအတွက်လည်း \fEn{SQL} ကိုပဲ သုံးရတာပါ။ 

\fEn{SQL} ဟာ \fEn{RDBMS} အားလုံးမှာ အသုံးပြုနိုင်တဲ့ \fEn{standard language} တစ်ခုလည်းဖြစ်တယ်။ ဆိုလိုတာက ဘယ် \fEn{RDBMS} ကိုပဲ သုံးသုံး၊ \fEn{SQL} တစ်မျိုးတည်းကိုပဲ သုံးရမှာပါ။ \fEn{RDBMS} တစ်ခုမှာ သူ့ကိုယ်ပိုင် ချဲ့ထွင်ထားတဲ့ အပိုင်းတွေ အနည်းအကျဉ်း ရှိကြပေမဲ့ \fEn{SQL standard} ကို ရာနှုန်းပြည့် မဟုတ်တောင် အဲ့လောက်နီးနီး လိုက်နာထားကြတဲ့အတွက် ပြောပလောက်အောင် မကွာကြဘူး။ \fEn{SQL} သာနားလည်ပါစေ၊ ဘယ်ဒေတာဘေ့စ်နဲ့မဆို အလုပ်ဖြစ်တယ်လို့ ပြောရင်လည်း မမှားဘူး။

\subsection*{Client-Server Applications}
တစ်ချိန်မှာ တစ်ယောက်ပဲ သုံးလို့ရတဲ့ ဆော့ဖ်ဝဲတွေနဲ့ မတူတာက \fEn{DBMS} တွေဟာ တစ်ယောက်မက တပြိုင်နက် သုံးလို့ရတဲ့ ဆာဗာ \fEn{(server)} ဆော့ဖ်ဝဲတွေ ဖြစ်ပါတယ်။ တပြိုင်နက် ဝင်ရောက်လာတဲ့ အသုံးပြုသူတွေရဲ့ တောင်းဆိုချက်တွေကို ဖြည့်ဆည်းဖို့အတွက် ကိုင်တွယ်ဆောင်ရွက် ပေးနိုင်စွမ်း ရှိတယ်။ 

တစ်ခုထက်ပိုတဲ့ \fEn{client} တွေက ဆာဗာတစ်ခုနဲ့ ချိတ်ဆက်အသုံးပြုတဲ့ ဆော့ဖ်ဝဲစနစ်မျိုးကို  \fEn{Client-Server Application} လို့ ခေါ်တယ်။ \fEn{Client} ဆိုတာ အသုံးပြုသူ \fEn{user} (သို့) ၎င်းအသုံးပြုတဲ့ ပရိုဂရမ်ကို ဆိုလိုတာ။ ဒေတာဘေ့စ် \fEn{application} အများစုဟာ \fEn{Client-Server Application} တွေပါ။ \fEn{Web Application} တွေဟာ \fEn{Client-Server Application} ဖြစ်ပြီး ဒေတာသိမ်းဖို့အတွက် နောက်ကွယ်က \fEn{RDBMS} တစ်ခုနဲ့ ချိတ်ဆက်ထားရလေ့ရှိတယ်။ 


\section{PostgreSQL}
ဒီစာအုပ်မှာ \fEn{PostgreSQL RDBMS} အသုံးပြုပါမယ်။ \fEn{PostgreSQL} ဘယ်လို အင်စတောလ်လုပ်မလဲ စာမျက်နှာ \fRefNo{\pageref{apdx3}} နောက်ဆက်တွဲ (\fRefNo{\ref{apdx3}}) မှာ ကြည့်ပါ။ \fEn{psql} ဖွင့်ပြီး \fEn{root user (postgres)} အနေနဲ့ \fEn{PostgreSQL} ဒေတာဘေ့စ်ကို ချိတ်ဆက်ထားပါ။

\subsection*{ဒေတာဘေ့စ် အသစ်ဆောက်ခြင်း}
ဒေတာဘေ့စ် အသစ်တစ်ခု ဆောက်မယ်ဆိုရင် \fCode{CREATE DATABASE} \fEn{SQL} ကွန်မန်း သုံးပါတယ်။  
%
\begin{sql}
CREATE DATABASE ß\fEnEmp{database\_name}ß;
\end{sql}
%
\fEn{SQL language} ဟာ စာလုံး အကြီးအသေး မခွဲဘူး။ ဒီစာအုပ်မှာ \fEn{SQL keyword} တွေဆိုရင် အက္ခရာအကြီးနဲ့ ရေးပါမယ်။ \fEn{Database, table, column, function} စတာတွေရဲ့ နံမည်တွေက အက္ခရာအသေးနဲ့ ဖြစ်မယ်။
\fEn{student} ဒေတာဘေ့စ် အတွက် ဒီ \fEn{SQL} ကို
%
\begin{sql}
CREATE DATABASE students;
\end{sql}
%
\fEn{psql} ကနေ \fEn{run} ပေးပါ $\big\llbracket$ပုံ (\fRefNo{\ref{fig:createdb}})$\big\rrbracket$။ \fEn{SQL} စတိတ်မန့် တစ်ကြောင်း အဆုံးမှာ ဆီမီးကော်လံ \fEn{(\fCode{;})} ထည့်ပေးရပါမယ်။

\begin{figure}[tb!]
\begin{tikzpicture}
    \node[anchor=south west,inner sep=0] (image) at (0,0)
    {\includegraphics[width=.98\linewidth]{images/ch12/createdb.jpg}};
    \drawshadow{image}
\end{tikzpicture}
\caption{}
\label{fig:createdb}
\end{figure}

\fEn{psql} ကနေ \mintinline{text}|\l| (သို့) \mintinline{text}|\list| ကွန်မန်းနဲ့ \fEn{PostgreSQL} မှာ ရှိတဲ့ ဒေတာဘေ့စ်တွေကို ထုတ်ကြည့်နိုင်ပါတယ်။ \mintinline{text}|\l| က \fEn{SQL} မဟုတ်ဘူး။ \fEn{psql} သီးသန့် ကွန်းမန်းတစ်ခုဖြစ်တာကြောင့် ဒီကွန်မန်းကို \fCode{;} မထည့်ဘဲ \fEn{run} ရပါမယ်။ \mintinline{text}|\l| \fEn{run} လိုက်ရင် စာရင်းထဲမှာ \fEn{students} ဒေတာဘေ့စ် တွေ့ရမှာပါ $\big\llbracket$ပုံ (\fRefNo{\ref{fig:listdb}})$\big\rrbracket$။

\begin{figure}[tb!]
\begin{tikzpicture}
    \node[anchor=south west,inner sep=0] (image) at (0,0)
    {\includegraphics[width=.98\textwidth, trim={0cm 2cm 38cm 0cm},clip]{images/ch12/listdb.jpg}};
    \drawshadow{image}
\end{tikzpicture}
\caption{}
\label{fig:listdb}
\end{figure}

\fEn{psql} မှာ ဒေတာဘေ့စ် ပြောင်းချိတ်မယ်ဆိုရင် \mintinline{text}|\c| (သို့) \mintinline{text}|\connect| နဲ့ ပြောင်းရပါမယ်။ \fEn{psql} သီးသန့် ကွန်မန်းပါ။ \fEn{Backslash (}\mintinline{text}|\|\fEn{)} စရင် \fEn{psql} ကွန်းမန်းလို့ မှတ်နိုင်တယ်။ \fEn{students} ဒေတာဘေ့စ်ကို အခုလို \fEn{connect} လုပ်ပါ
\begin{codetxt}
\c students
\end{codetxt}
\fEn{psql} က ဒီလို ပြပါလိမ့်မယ်
\begin{codetxt}
postgres=# \c students
You are now connected to database "students" as user "postgres".
students=#
\end{codetxt}


\subsection*{Table ဆောက်ခြင်း}
\fCode{CREATE TABLE} က \fEn{table} ဆောက်တဲ့ \fEn{SQL} ကွန်မန်းပါ။ \fEn{students} ဒေတာဘေ့စ်ထဲမှာ \fEn{student table} အောက်ပါအတိုင်း ဆောက်ပါမယ်
%
\begin{sql}
CREATE TABLE student (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    grade VARCHAR(2)
);
\end{sql}
%  
\fEn{psql} မှာ \fEn{SQL} \fEn{run} ရင် လက်ရှိချိတ်ထားတဲ့ ဒေတာဘေ့စ်ကို အဲဒီ \fEn{SQL} ပေးပို့ လုပ်ဆောင်ခိုင်းပါတယ်။ အခုချိတ်ထားတာ \fEn{students} ဒေတာဘေ့စ်ဆိုတော့ \fEn{table} ကို အဲဒီ ဒေတာဘေ့စ်ထဲ ဆောက်ပေးသွားမှာပါ။ ဒီ \fEn{table} မှာ \fCode{id}\fEn{,} \fCode{name}\fEn{,} \fCode{age} နဲ့ \fCode{grade} \fEn{column} လေးခုရှိမယ်။

\fEn{Column} တစ်ခုစီမှာ \fEn{data type} ရှိရပါမယ်။ \fCode{VARCHAR(100)} က အများဆုံး ကာရက်တာ အလုံးတစ်ရာ သိမ်းဆည်းနိုင်တယ်။ သိမ်းတဲ့ ကာရက်တာ အရေအတွက်ပေါ် မူတည်ပြီး နေရာယူတာ အနည်းအများ ကွာတယ်။ ငါခုသိမ်းရင် ငါးခုစာ၊ ဆယ်ခုသိမ်းရင် ဆယ်ခုစာပဲ နေရာကုန်မှာပါ။ အမြဲ အလုံး တစ်ရာစာ နေရာကုန်တာ မဟုတ်ဘူး။ \fCode{VARCHAR(2)} ဆိုရင် အများဆုံး  ကာရက်တာ နှစ်လုံး သိမ်းလို့ရမယ်။ \fEn{SQL} \fCode{VARCHAR} က \fEn{Python} \fCode{str} နဲ့ အလားတူတယ်။ \fCode{INT} ကတော့ \fEn{integer} ပါ။

\fCode{id} \fEn{column} က ထူးခြားပြီး နည်းနည်းပိုရှင်းပြဖို့ လိုတယ်။ \fCode{SERIAL} က \fEn{data type} အနေနဲ့ \fCode{INT} နဲ့ တူတူပဲ။ သူ့ရဲ့ ထူးခြားချက်က ဂဏန်းတွေကို အစဉ်အတိုင်း တစ်ခုပြီးတစ်ခု ထုတ်ပေးနိုင်တာပါ။ $1, 2, 3,\ldots$ စသည်ဖြင့်  နောက်ဆုံးတန်ဖိုးကို အလိုအလျောက် တစ်တိုးတိုးပြီး ထုတ်ပေးသွားမှာ ဖြစ်တယ်။ \fCode{id} \fEn{column} က \fEn{Primary Key} လည်းဖြစ်တယ်။ \fEn{Column} တစ်ခုကို \fEn{Primary Key} အဖြစ် ထားချင်ရင် \fCode{PRIMARY KEY} လို့ သတ်မှတ်ရပါမယ်။ \fEn{Primary Key} ဆိုရင် \fEn{column} တန်ဖိုး ထပ် \fEn{(duplicate)} လို့မရဘူး၊ \fEn{unique} ဖြစ်ရပါမယ်။ အခု သိပ်နားမလည်သေးရင်လည်း \fEn{table} မှာ ကျောင်းသား \fEn{record} တွေထည့်တာ ဆက်ကြည့်ရင် ကောင်းကောင်း နားလည်သွားမှာပါ။

\subsection*{\fSubSecCodeBf{INSERT}}
\fEn{Relational Data Model} အခြေခံတဲ့ \fEn{RDBMS} တွေဟာ ဒေတာတွေကို \fEn{table} ပုံစံနဲ့ သိမ်းဆည်းတယ်။ ကျောင်းသူ/သား တစ်ယောက်ချင်းစီအတွက် အချက်အလက်ကို \fEn{student table} မှာ  \fEn{row} တစ်ခုစီနဲ့ ထည့်သွင်း သိမ်းဆည်းပါမယ်။ \fEn{Row} ကို \fEn{record} လို့လည်း သုံးနှုန်းလေ့ရှိတယ်။ \fEn{Record} အသစ် ထည့်သွင်းမယ်ဆိုရင် \fEn{SQL} \fCode{INSERT} ကို သုံးရပါတယ်။

%
\begin{sql}
INSERT INTO student (name, age, grade) VALUES ('Amy', 20, 'A');
INSERT INTO student (name, age, grade) VALUES ('Kathy', 22, 'B');
INSERT INTO student (name, age, grade) VALUES ('Waiyan', 21, 'C');
\end{sql}
%

အေမီ၊ ကေသီ နဲ့ ဝေယံ ကျောင်းသား သုံးယောက်အတွက် \fEn{record} သုံးခု ထည့်သွင်းတာပါ။ \fEn{Column} နံမည်တွေ ဝိုက်ကွင်းထဲမှာ ထည့်ပြီး အဲ့ဒီ \fEn{column} တွေအတွက် တန်ဖိုးအသီးသီးကို အစဉ်အတိုင်း ထည့်ပေးရပါတယ်။ \fCode{age} နဲ့ \fCode{grade} ရှေ့နောက် ဖလှယ်လိုက်မယ်ဆိုရင် အခုလို
%
\begin{sql}
INSERT INTO student (name, grade, age) VALUES ('Amy', 'A',  20);
\end{sql}
%
ဖြစ်ရမှာပါ။

\fEn{student table} မှာ \fEn{column} က လေးခု ရှိတာပါ။ အခု \fCode{INSERT} တွေမှာကျတော့ သုံးခုပဲတွေ့ရပြီး \fCode{id} မပါဘူး။ ဘာကြောင့်ပါလဲ။ \fCode{INSERT} လုပ်တဲ့အခါ \fCode{SERIAL} \fEn{column} အတွက် တန်ဖိုးကို ဒေတာဘေ့စ်က အလိုအလျောက် ထည့်ပေးသွားတာ။ ကိုယ်တိုင်ထည့်ဖို့ မလိုဘူး။ ဒါကြောင့် \fCode{id} \fEn{column} ကို \fEnEmp{auto-incrementing} \fEn{primary key} \fEn{column} လို့ ခေါ်တယ်။ \fEn{Auto-increment} ဖြစ်ဖို့ အခြားနည်းလမ်းတွေလည်း ရှိပါတယ်။ \fCode{SERIAL} ကတော့ ဒီကိစ္စအတွက် လွယ်အောင် လုပ်ပေးထားတာပါ။ စောစောက \fCode{INSERT} သုံးကြောင်းကို \fEn{psql} မှာ \fEn{run} ပါ။ အေမီ၊ ကေသီ နဲ့ ဝေယံတို့အတွက် \fEn{record} အသီးသီးကို \fCode{id} နံပါတ် $1,2,3$ အစဉ်နဲ့ \fEn{student table} ထဲ ထည့်သွင်းသွားမှာဖြစ်တယ်။ နောက်ထပ် \fEn{record} တစ်ခု ထပ်ထည့်ရင် \fCode{id} နံပါတ် $4$ ဖြစ်မှာပါ။


\subsection*{\fSubSecCodeBf{SELECT}}
\fEn{Table} ဒေတာတွေ ထုတ်ယူကြည့်ဖို့ အသုံးပြုတဲ့ \fEn{SQL} ဖြစ်ပါတယ်။ \fEn{Student table} ထဲက \fEn{record} အားလုံးကို ကြည့်မယ်ဆို အခုလို 
%
\begin{sql}
SELECT id, name, age, grade FROM student;
\end{sql}
%
\fEn{Table} မှာ ရှိသမျှ \fEn{column} အကုန်လုံး ပါချင်ရင် \fCode{SELECT *} သုံးလို့လည်းရတယ်။ \fCode{SELECT *} ကို \fEn{‘Select All’} လို့ ဖတ်တယ်။
%
\begin{sql}
SELECT * FROM student;
\end{sql}
%

\begin{figure}[tbh!]
\begin{tikzpicture}
  \node[anchor=south west,inner sep=0] (image) at (0,0)
  {\includegraphics[width=.98\textwidth]{images/ch12/select.jpg}};
  \drawshadow{image}
\end{tikzpicture}
\caption{} 
\label{fig:selectstu}
\end{figure}

\fEn{Column} အကုန်မထုတ်ဘဲ ကိုယ်လိုချင်တာပဲ ရွေးပြီး \fEn{select} လုပ်ချင်လည်း ရတယ်။ အောက်ပါတို့ကို \fEn{psql} မှာ စမ်းကြည့်ပါ။
%
\begin{sql}
SELECT name, grade FROM student;
SELECT name, age, id FROM student;
\end{sql}
%
\subsection*{\fSubSecCodeBf{WHERE}}
\fEn{Grade A} ရတဲ့ ကျောင်းသားတွေကိုပဲ ရွေးထုတ်ကြည့်မယ် ဆိုပါစို့။ ဒီအတွက် \fEn{SQL} မှာ \fCode{WHERE} ရှိပါတယ်။ ဥပမာ
%
\begin{sql}
SELECT * FROM student WHERE grade = 'A';
\end{sql}
%
\fCode{WHERE} မှာ ဘူလီယန် အိပ်စ်ပရက်ရှင် ပါရပါမယ်။ ရေးပုံရေးနည်း နည်းနည်းကွာပေမဲ့ \fEn{SQL} ဘူလီယန် အိပ်စ်ပရက်ရှင်က \fEn{Python} နဲ့ သဘောတရားအားဖြင့် တူပါတယ်။ \fCode{grade = 'A'} က \fCode{grade} \fEn{column} တန်ဖိုး \fCode{'A'} နဲ့ ညီလား စစ်တာ။ ညီတဲ့ \fEn{record} တွေကိုပဲ \fCode{WHERE} က စစ်ထုတ်ပေးမှာပါ။ ဒါ့ကြောင့် အပေါ်က \fCode{select} က \fEn{record} တစ်ကြောင်းပဲ ထွက်မှာပါ။ အေမီတစ်ယောက်ပဲ \fEn{A} ရပါတယ်။ အခြား ဘူလီယန် အိပ်စ်ပရက်ရှင်တွေ လက်တွေ့စမ်းကြည့်ဖို့အတွက် အောက်ပါအတိုင်း ကျောင်းသား \fEn{record} သုံးခု ထပ်ထည့်ထားပါ။  
%
\begin{sql}
INSERT INTO student (name, age, grade) VALUES ('Sandy', 19, 'A');
INSERT INTO student (name, age, grade) VALUES ('Thida', 21, 'B');
INSERT INTO student (name, age, grade) VALUES ('Peter', 21, 'B');
INSERT INTO student (name, age, grade) VALUES ('Haymar', 18, NULL);
\end{sql}
%

%
\begin{sql}
-- 
SELECT * FROM student WHERE grade = 'A' OR grade = 'B';
--
SELECT * FROM student WHERE grade = 'B' AND id <= 5;
--
SELECT * FROM student WHERE grade <> 'C';
--
SELECT * FROM student WHERE grade IS NULL;
--
SELECT * FROM student WHERE grade IS NOT NULL;
\end{sql}
%

\subsection*{\fSubSecCodeBf{UPDATE}}


\subsection*{\fSubSecCodeBf{DELETE}}

  

\section{Database API}

\subsection*{\fSubSecCodeBf{psycopg2}}
% Psycopg is the most popular PostgreSQL database adapter for the Python programming language. 
\fEn{Python programming language} အတွက် \fEn{Psycopg} ဟာ \fEn{popular} အဖြစ်ဆုံး  \fEn{PostgreSQL} ဒေတာဘေ့စ် \fEn{adapter} ဖြစ်ပါတယ်။ ဒေတာဘေ့စ် \fEn{adapter} ဆိုတာ \fEn{DBMS} နဲ့ \fEn{programming language} ကြား ပေါင်းကူးတံတားအဖြစ် ဆောင်ရွက်ပေးတဲ့ လိုက်ဘရီပဲ ဖြစ်တယ်။

\fEn{Adapter} သုံးတဲ့အခါ \fEn{DBMS} နဲ့ \fEn{programming language} အလိုက် သက်ဆိုင်ရာ \fEn{adapter} ကို ရွေးချယ်ရမှာပါ။ \fEn{PostgreSQL} အတွက် \fEn{Python} မှာ \fEn{Psycopg 2} နဲ့ \fEn{Psycopg 3} ရှိမယ်။ အခြားဟာတွေလည်း ရှိပါသေးတယ်။ \fEn{MySQL} အတွက် \fEn{MySQL Connector/Python} သုံးကြတယ်။ \fEn{Microsoft SQL} အတွက်ဆိုရင် \fEn{pyodbc}။  

\subsection*{Connecting to PostgreSQL}
\fEn{Python} ကနေတစ်ဆင့် ဒေတာဘေ့စ် အသစ်တစ်ခု ဘယ်လိုဆောက်မလဲ ကြည့်ရအောင်။ စောစောက ပြောတဲ့ \fCode{psycopg2} \fEn{adaptor install} လုပ်ထားပြီး ဖြစ်ရပါမယ်။
%
\begin{py}
import psycopg2

# Connect to the default PostgreSQL database to create 
# the new "students" database
conn = psycopg2.connect(
    dbname="postgres",
    user="postgres",
    password="asdfgh",
    host="localhost",
    port="5432"
)

conn.autocommit = True
cur = conn.cursor()

# Create the "students" database
cur.execute("CREATE DATABASE students")

# Close the initial connection
cur.close()
conn.close()
\end{py}
%
ဒီပရိုဂရမ်ကို ခွဲခြမ်းစိတ်ဖြာ ကြည့်ရအောင်။ \fCode{psycopg2} မော်ဒျူး အင်ပို့ လုပ်ပါတယ်။ ပြီးတော့ \fCode{connect} ဖန်ရှင်နဲ့ \fEn{connection} ယူတယ်။ ပါရာမီတာ တစ်ခုစီရဲ့ အဓိပ္ပါယ်က
%
\begin{itemize}
    \item \fCode{dbname} မှာ ချိတ်ဆက်မဲ့ ဒေတာဘေ့စ်နံမည် ထည့်ပေးရမယ်၊ \fEn{default} ဒေတာဘေ့စ်နဲ့ ချိတ်ဆက်မှာဆိုတော့ \fCode{postgres} ပဲ
    \item \fCode{user} က ဘယ်သူအနေနဲ့ ချိတ်ဆက်အသုံးပြုမှာလဲ၊ \fEn{root user} ဖြစ်တဲ့ \fCode{postgres} အနေနဲ့ပဲ ချိတ်ဆက်မှာ 
    \item \fCode{password} က ချိတ်ဆက် အသုံးပြုမဲ့သူရဲ့ \fEn{password} ၊ \fEn{root user} \fCode{postgres} ရဲ့ \fEn{password} ထည့်မယ် 
    \item \fCode{host} ကတော့ ဒေတာဘေ့စ် ဆာဗာရဲ့ \fEn{IP address} (သို့) \fEn{host} နံမည်၊ ဒေတာဘေ့စ် ဆာဗာက ကိုယ့်ကွန်ပျူတာမှာပဲဆိုရင် \fEn{127.0.0.1} (သို့) \fEn{localhost} ထည့်နိုင်တယ် (အခြားကွန်ပျူတာမှာ \fEn{run} ထားတဲ့ ဒေတာဘေ့စ် ဆိုရင် အဲ့ဒီ ကွန်ပျူတာရဲ့ \fEn{IP address} သို့ \fEn{domain name} ရှိရင် \fEn{domain name} ထည့်ပေးလို့ရတယ်) 
    \item \fCode{port} \fEn{PostgreSQL} ဒေတာဘေ့စ် \fEn{port} နံပါတ်၊ အင်စတောလ်လုပ်တုံးက ပေးခဲ့တဲ့ \fEn{port} နံပါတ် ပြန်ထည့်ပေးရမယ်
\end{itemize}
%
\fEn{Connect} လုပ်တာ အောင်မြင်ရင် \fCode{connect} ဖန်ရှင်က \fCode{Connection} အော့ဘ်ဂျက်တစ်ခု ပြန်ရပါတယ်။ တကယ်လို့ ပြဿနာ တစ်ခုခုကြောင့် \fEn{connect} လုပ်လို့ မရရင်တော့ ဖြစ်ရတဲ့ အကြောင်းအရင်းပေါ် မူတည်ပြီး \fCode{OperationalError}\fEn{,} \fCode{InternalError} စတဲ့ \fEn{exception} တွေ တက်နိုင်တယ်။ ဒီ \fEn{exception} တွေက \fCode{psycopg2.Error}  ရဲ့ \fEn{subclass} တွေပါ။ \fEn{built-in} တွေ မဟုတ်ပါဘူး၊ \fCode{psycopg2} သီးသန့် \fEn{exception} တွေပါ။


%
\begin{py}
conn.autocommit = True
\end{py}
%
ဒါက ဒေတာဘေ့စ် \fEnEmp{auto-commit} \fEn{mode} ကို \fEn{on} လုပ်ပေးဖို့။ ဒေတာဘေ့စ် \fEn{transaction} နဲ့ ဆိုင်တဲ့ \fEn{setting} တစ်ခုဖြစ်ပြီး နောက်ပိုင်းမှာ အသေးစိတ် ရှင်းပြမှာပါ။ \fEn{PostgreSQL} က နဂိုအတိုင်း  \fEn{auto commit mode} ကို \fEn{off} လုပ်ထားတယ်။ ဒေတာဘေ့စ် အသစ်ဆောက်တဲ့ \fCode{CREATE DATABASE} လို တချို့ \fEn{SQL} စတိတ်မန့်တွေက \fEn{auto commit} ကို \fEn{on} လုပ်ပေးရတယ်လို့ လောလောဆယ် သိထားရင် လုံလောက်ပါပြီ။ \fEn{On} ထားရင် \fEn{SQL} စတိတ်မန့်တွေ \fCode{execute} လုပ်ပြီးရင် \fCode{commit} ဖန်ရှင် ခေါ်ဖို့ မလိုဘူး။ (နောက် ဥပမာမှာ \fCode{commit} ဖန်ရှင် သုံးထားတာ တွေ့ရမှာပါ)။

\fEn{SQL} စတိတ်မန့်တွေ ဒေတာဘေ့စ်ဆီ ပေးပို့လုပ်ဆောင်စေခြင်း၊ ဒေတာဘေ့စ်ဆီက ပြန်ရလာတဲ့ ရလဒ်တွေကို အသုံးပြုခြင်း၊ ဒေတာဘေ့စ် \fEn{transaction} စီမံခြင်း စတဲ့ ကိစ္စတွေအတွက် \fEn{cursor} က အဓိကကျတယ်။ \fEn{Cursor} အော့ဘ်ဂျက်ကို \fEn{connection} ကနေ တစ်ဆင့် အခုလို ယူရပါတယ်
%
\begin{py}
cur = conn.cursor()
\end{py}
%

\fEn{students} ဒေတာဘေ့စ် ဆောက်တဲ့ \fEn{SQL} ကို ဒေတာဘေ့စ် ဆာဗာဆီ \fEn{cursor} နဲ့ ပေးပို့ လုပ်ဆောင်ခိုင်းရပါမယ်။ 
%
\begin{py}
cur.execute("CREATE DATABASE students")
\end{py}
%

\fEn{Cursor} နဲ့ \fEn{connection} ကို အသုံးပြုပြီးသွားရင် ပိတ်ပေးသင့်တယ်။ \fEn{Exception handle} လုပ်မယ်ဆိုရင် \fCode{finally} ထဲမှာ ပိတ်ရမယ်။ ဒီဥပမာမှာတော့ ရိုးရိုးပဲ ပိတ်ထားပါတယ်။
%
\begin{py}
cur.close()
conn.close()
\end{py}
%

ဒီပရိုဂရမ် \fEn{run} ပြီးလို့ ဘာပြဿနာမှမရှိဘဲ အောင်မြင်တယ်ဆိုရင် \fEn{students} ဒေတာဘေ့စ် ဆောက်ပြီးသွားပါပြီ။ \fEn{psql} မှာ \mintinline{text}|\l| ကွန်မန်း \fEn{run} ကြည့်ရင် အခုလို တွေ့ရမှာပါ။
(သို့) \fEn{pgAdmin} 


\begin{figure}[tb!]
\begin{tikzpicture}
    \node[anchor=south west,inner sep=0] (image) at (0,0)
        {\includegraphics[width=.98\textwidth, trim={0cm 7cm 38cm 0cm},clip]{images/ch12/lstdbstu.jpg}};
    \drawshadow{image}
\end{tikzpicture}
\caption{}
\label{fig:lstdbstu}
\end{figure}



ဒေတာဘေ့စ်ထဲမှာ \fEn{table} တွေ ဆောက်ပါမယ်။ လက်ရှိအသုံးပြုမဲ့ ဒေတာဘေ့စ်နဲ့ \fEn{connection} အရင်ယူရမယ်။ \fEn{students} ဒေတာဘေ့စ်မှာ  \fEn{table} ဆောက်မှာ။ ဒီတော့ ချိတ်ဆက်မဲ့ \fCode{dbname} က \fCode{students} ဖြစ်တယ်။ ကျန်တာတွေက ရှေ့ကနဲ့ တူတူပဲ။
%
\begin{py}
import psycopg2

# Now, connect to the "students" database to create the "student" table
conn = psycopg2.connect(
    dbname="students",
    user="postgres",
    password="asdfgh",
    host="localhost",
    port="5432"
)
cur = conn.cursor()

# Create the "student" table
cur.execute("""
    CREATE TABLE student (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100),
        age INT,
        grade VARCHAR(2)
    )
""")

# Commit changes and close the connection
conn.commit()
cur.close()
conn.close()
\end{py}
%

\fEn{Table} ဆောက်တဲ့ \fCode{CREATE TABLE} စတိတ်မန့်က  \fEn{auto-commit mode} \fEn{ON} ဖြစ်ဖြစ်၊ \fEn{OFF} ဖြစ်ဖြစ် \fEn{run} လို့ရတယ်။ \fEn{PostgreSQL} မှာ \fEn{default} က \fEn{OFF} ဖြစ်တယ်။ \fEn{Connection} ယူပြီးတာနဲ့ အခုလို တကူးတက ထည့်ပေးမယ်ဆိုရင်လည်း ပြဿနာတော့ မရှိပါဘူး။ 
%
\begin{py}
conn.autocommit = False
\end{py}
%
\fEn{Default} က \fEn{OFF} ဖြစ်ပြီးသားမို့လို့ လိုတော့မလိုအပ်ဘူး။

\fEn{Auto-commit} \fEn{OFF} ထားရင် \fEn{SQL} စတိတ်မန့် \fEn{execute} လုပ်ပြီး \fEn{commit} လုပ်ပေးဖို့ လိုတယ်။ ဒီအတွက်
%
\begin{py}
conn.commit()
\end{py}
%
လုပ်ရပါမယ်။ ဒါ မေ့ကျန်ခဲ့ရင် \fEn{execute} လုပ်ထားတဲ့ \fEn{SQL} က သက်ရောက်မှု ရှိမှာမဟုတ်ပါဘူး။ တစ်နည်းအားဖြင့် \fEn{student table} အမှန်တကယ် မဆောက်ပေးတော့ဘူး။ အကယ်၍ \fEn{auto-commit} \fEn{OFF} ထားရင်တော့ ကိုယ်တိုင် \fCode{conn.commit()} လုပ်မပေးရဘူး၊ ဒေတာဘေ့စ်က \fEn{SQL} ကွန်မန်း တစ်ခု \fEn{execute} လုပ်ပြီးတိုင်း အလိုအလျောက် \fEn{commit} လုပ်ပေးမှာပါ။ \fEn{OFF} ထားရင် \fCode{conn.commit()} လုပ်ပေးရမယ်၊ \fEn{ON} ဆိုရင် မလုပ်ပေးရဘူး၊ ဒီလို မှတ်ထားလို့ရတယ်။


